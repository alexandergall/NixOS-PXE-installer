## This function creates a tarball that contains an almost complete
## NixOS system by copying the closure of the toplevel derivation of a
## given system configuration.  The configuration is composed of a
## complete nixpkgs directory tree and a directory that contains a
## nixos configuration.  The former must be supplied as a "channel
## derivation", i.e. the output of <nix/unpack-channel.nix>.  This
## derivation will be included in the system and configured as initial
## nixos channel.
##
## The tarball is intended to be used by the fully-automated PXE-based
## installer, which will complete the installation by
##
##   generating the configuration that depends on the hardware of the
##   system
##
##   installing the system configuration into the systems profile
##   and switching to that profile
##
##   Activating the new configuration
##
{ pkgs
, lib

, system

, # The system is constructed in a VM using a virtual disk of size
  # diskSize and memSize virtual RAM, both in MiB
  diskSize ? 2048
, memSize ? 1024

  # A derivation that contains a copy of the NixOS sources of the
  # system in the form of a channel named "nixos".
, channel

, # The absolute path to a directory that will be
  # copied to /etc/nixos on the system.  It must contain a file
  # named configuration.nix, which will be included as a module
  # when the system configuration is evaluated.
  #
  # If the argument is omitted, an empty directory will be installed
  # and a basic configuration.nix will be generated by
  # "nixos-generate-config" when the system is installed.
  nixosConfigDir ? null

, # A list of packages whose closures will be added to
  # that of systemConfigPath.  It is used to add packages
  # which are not part of the system closure in the default
  # NixOS configuraion (e.g. because a service is disabled
  # by default).
  additionalPkgs

, # The name of the tarball to store in the derivation. The compression
  # algorithm is chosen based on the extension of the name via the
  # "--auto-compress" feature of tar.
  tarballName

, # Shell code executed after the VM has finished.
  postVM ? ""

}:

with lib;

let

  ## Create the system configuration from the supplied NixOS system
  ## definition.  The closure of the system.build.toplevel derivation
  ## will be installed on the client.  The actual configuration of the
  ## installed client will be slightly different due to the
  ## hardware-dependent components generated by
  ## "nixos-generate-config" and the network configuration.  At the
  ## end of the installation process, the installer essentially
  ## executes "nix-env -p /nix/var/nix/profiles/system -f
  ## '<nixpkgs/nixos>' --set -A system" to generate the final
  ## configuration, which is executed in the context of the supplied
  ## channel.
  extraConfig = {
    hardware.enableAllFirmware = true;
    fileSystems."/".device = "/none";
    boot.loader.grub.device = "/none";
  };
  config =(import (channel + "/nixos/nixos/lib/eval-config.nix") {
    inherit system;
    modules = [ extraConfig ] ++
      optional (nixosConfigDir != null && (pathExists nixosConfigDir))
        (nixosConfigDir + "/configuration.nix");
  }).config;

  version = builtins.unsafeDiscardStringContext
    (builtins.substring 33 (-1) (baseNameOf channel));

in pkgs.vmTools.runInLinuxVM (
  let
    configDir = optionalString (nixosConfigDir != null) nixosConfigDir;
  in pkgs.runCommand "install-tarball-${version}"
    { preVM =
        ''
          mkdir $out
          diskImage=nixos.img
          ${pkgs.vmTools.qemu}/bin/qemu-img create -f raw $diskImage "${toString diskSize}M"
          mv closure* xchg/
          if [ -n "${configDir}" ]; then
            cp -prd ${configDir} xchg/
          fi
        '';
      buildInputs = [ pkgs.utillinux pkgs.perl pkgs.e2fsprogs ];
      exportReferencesGraph =
        with (import (channel + "/nixos") { inherit system; }).pkgs;
        map (x: [("closure-" + baseNameOf x) x])
          ([config.system.build.toplevel
            channel
            ## Build-time dependencies for activating
            ## the final NixOS configuration on the
            ## installed system.
            ## FXME: Determine this reliably from pkgs
            stdenv
            busybox
            config.system.build.bootStage1
            unzip
            perlArchiveCpio
          ] ++ additionalPkgs);
      inherit postVM diskSize memSize configDir;
    }
    ''
      rootDisk=/dev/vda

      # Create an empty filesystem and mount it.
      mkfs.ext4 -L nixos $rootDisk
      mkdir /mnt
      mount $rootDisk /mnt

      for dir in dev proc sys; do
        mkdir /mnt/$dir
        mount -o bind /$dir /mnt/$dir
      done

      mkdir /mnt/tmp
      chmod 1777 /mnt/tmp
      mkdir /mnt/etc

      # Copy all paths in the closure to the filesystem.
      closures=/tmp/xchg/closure*
      storePaths=$(perl ${pkgs.pathsFromGraph} $closures)

      mkdir -p /mnt/nix/store
      echo "copying closures..."
      set -f
      n=$(echo $storePaths | wc -w)
      i=1
      for p in $storePaths; do
        echo "($i/$n)" $p
        cp -prd $p /mnt/nix/store/
        i=$(($i+1))
      done
      set +f

      # Register the paths in the Nix database.
      printRegistration=1 perl ${pkgs.pathsFromGraph} $closures | \
          chroot /mnt ${config.nix.package}/bin/nix-store --load-db --option build-users-group ""

      # Add missing size/hash fields to the database. FIXME:
      # exportReferencesGraph should provide these directly.
      chroot /mnt ${config.nix.package}/bin/nix-store --verify --check-contents

      # `nixos-rebuild' requires an /etc/NIXOS.
      touch /mnt/etc/NIXOS

      # `switch-to-configuration' requires a /bin/sh
      mkdir -p /mnt/bin
      ln -s ${config.system.build.binsh}/bin/sh /mnt/bin/sh

      # Set up the initial NixOS channel
      echo "nixbld1:x:30001:30000:Nix build user 1:/var/empty:/run/current-system/sw/bin/nologin" >/mnt/etc/passwd
      echo "nixbld:x:30000:nixbld1" >/mnt/etc/group
      mkdir -p /mnt/nix/var/nix/profiles/per-user/root
      NIX_REMOTE= NIX_SUBSTITUTERS= chroot /mnt ${config.nix.package}/bin/nix-env \
               -p /nix/var/nix/profiles/per-user/root/channels \
               -i ${channel}
      mkdir -m 0700 -p /mnt/root/.nix-defexpr
      ln -sfn /nix/var/nix/profiles/per-user/root/channels /mnt/root/.nix-defexpr/channels
      mkdir -m 0755 -p /mnt/var/lib/nixos

      # Subscribe the root user to this channel.  If not done here,
      # this will happen via /etc/profile when root logs in for the
      # first time.
      echo "${config.system.defaultChannel} nixos" >/mnt/root/.nix-channels

      # Create a symlink to nix-env, which will be used by the installer to
      # generate the system configuration on the target system.  This makes
      # the Nix configuration of the target completely independent from that
      # of the installer, i.e. the same installer can configure targets for an
      # arbitrary release given the archive created here.  The symlink
      # will be removed by the installer.
      ln -s ${config.nix.package}/bin/nix-env /mnt/nix-env

      # Copy the NixOS configuration from which the system configuration
      # was created.
      mkdir /mnt/etc/nixos
      if [ -n "${configDir}" ]; then
        (cd /tmp/xchg/$(basename ${configDir}) && tar --exclude="*~" -cf - .) | (cd /mnt/etc/nixos && tar xf -)
      fi

      umount /mnt/proc /mnt/dev /mnt/sys
      echo "creating tarball from disk image"
      (cd /mnt && tar --checkpoint=.1000 -caf /tmp/xchg/${tarballName} .)
      umount /mnt
    ''
)
